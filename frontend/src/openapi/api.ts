/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration"
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios"
import globalAxios from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common"
import type { RequestArgs } from "./base"
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base"

/**
 *
 * @export
 * @interface Cof
 */
export interface Cof {
	/**
	 *
	 * @type {string}
	 * @memberof Cof
	 */
	cof_id: string
	/**
	 *
	 * @type {string}
	 * @memberof Cof
	 */
	date_roasted?: string | null
	/**
	 *
	 * @type {string}
	 * @memberof Cof
	 */
	date_best_by?: string | null
	/**
	 *
	 * @type {string}
	 * @memberof Cof
	 */
	name: string
	/**
	 *
	 * @type {number}
	 * @memberof Cof
	 */
	user: number
}
/**
 *
 * @export
 * @interface CofComment
 */
export interface CofComment {
	/**
	 *
	 * @type {string}
	 * @memberof CofComment
	 */
	cofcomment_id: string
	/**
	 *
	 * @type {string}
	 * @memberof CofComment
	 */
	comment_name?: string
	/**
	 *
	 * @type {string}
	 * @memberof CofComment
	 */
	comment: string
	/**
	 *
	 * @type {string}
	 * @memberof CofComment
	 */
	comment_posted: string
	/**
	 *
	 * @type {string}
	 * @memberof CofComment
	 */
	cof_id: string
	/**
	 *
	 * @type {string}
	 * @memberof CofComment
	 */
	cofpull_id?: string | null
}
/**
 *
 * @export
 * @interface CofPull
 */
export interface CofPull {
	/**
	 *
	 * @type {string}
	 * @memberof CofPull
	 */
	cofpull_id: string
	/**
	 *
	 * @type {string}
	 * @memberof CofPull
	 */
	grams_in?: string | null
	/**
	 *
	 * @type {string}
	 * @memberof CofPull
	 */
	grams_out?: string | null
	/**
	 *
	 * @type {number}
	 * @memberof CofPull
	 */
	duration_seconds?: number | null
	/**
	 *
	 * @type {string}
	 * @memberof CofPull
	 */
	cof_id: string
}
/**
 *
 * @export
 * @interface PatchedCof
 */
export interface PatchedCof {
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCof
	 */
	cof_id?: string
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCof
	 */
	date_roasted?: string | null
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCof
	 */
	date_best_by?: string | null
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCof
	 */
	name?: string
	/**
	 *
	 * @type {number}
	 * @memberof PatchedCof
	 */
	user?: number
}
/**
 *
 * @export
 * @interface PatchedCofComment
 */
export interface PatchedCofComment {
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofComment
	 */
	cofcomment_id?: string
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofComment
	 */
	comment_name?: string
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofComment
	 */
	comment?: string
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofComment
	 */
	comment_posted?: string
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofComment
	 */
	cof_id?: string
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofComment
	 */
	cofpull_id?: string | null
}
/**
 *
 * @export
 * @interface PatchedCofPull
 */
export interface PatchedCofPull {
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofPull
	 */
	cofpull_id?: string
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofPull
	 */
	grams_in?: string | null
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofPull
	 */
	grams_out?: string | null
	/**
	 *
	 * @type {number}
	 * @memberof PatchedCofPull
	 */
	duration_seconds?: number | null
	/**
	 *
	 * @type {string}
	 * @memberof PatchedCofPull
	 */
	cof_id?: string
}

/**
 * CofcommentApi - axios parameter creator
 * @export
 */
export const CofcommentApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {CofComment} cofComment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentCreate: async (
			cofComment: CofComment,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofComment' is not null or undefined
			assertParamExists("cofcommentCreate", "cofComment", cofComment)
			const localVarPath = `/cofcomment/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				cofComment,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentDestroy: async (
			cofcommentId: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofcommentId' is not null or undefined
			assertParamExists("cofcommentDestroy", "cofcommentId", cofcommentId)
			const localVarPath = `/cofcomment/{cofcomment_id}/`.replace(
				`{${"cofcomment_id"}}`,
				encodeURIComponent(String(cofcommentId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentList: async (
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/cofcomment/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {PatchedCofComment} [patchedCofComment]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentPartialUpdate: async (
			cofcommentId: string,
			patchedCofComment?: PatchedCofComment,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofcommentId' is not null or undefined
			assertParamExists(
				"cofcommentPartialUpdate",
				"cofcommentId",
				cofcommentId
			)
			const localVarPath = `/cofcomment/{cofcomment_id}/`.replace(
				`{${"cofcomment_id"}}`,
				encodeURIComponent(String(cofcommentId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedCofComment,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentRetrieve: async (
			cofcommentId: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofcommentId' is not null or undefined
			assertParamExists(
				"cofcommentRetrieve",
				"cofcommentId",
				cofcommentId
			)
			const localVarPath = `/cofcomment/{cofcomment_id}/`.replace(
				`{${"cofcomment_id"}}`,
				encodeURIComponent(String(cofcommentId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {CofComment} cofComment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentUpdate: async (
			cofcommentId: string,
			cofComment: CofComment,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofcommentId' is not null or undefined
			assertParamExists("cofcommentUpdate", "cofcommentId", cofcommentId)
			// verify required parameter 'cofComment' is not null or undefined
			assertParamExists("cofcommentUpdate", "cofComment", cofComment)
			const localVarPath = `/cofcomment/{cofcomment_id}/`.replace(
				`{${"cofcomment_id"}}`,
				encodeURIComponent(String(cofcommentId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				cofComment,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CofcommentApi - functional programming interface
 * @export
 */
export const CofcommentApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		CofcommentApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {CofComment} cofComment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofcommentCreate(
			cofComment: CofComment,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CofComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofcommentCreate(
					cofComment,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofcommentDestroy(
			cofcommentId: string,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofcommentDestroy(
					cofcommentId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofcommentList(
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<CofComment>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofcommentList(options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {PatchedCofComment} [patchedCofComment]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofcommentPartialUpdate(
			cofcommentId: string,
			patchedCofComment?: PatchedCofComment,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CofComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofcommentPartialUpdate(
					cofcommentId,
					patchedCofComment,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofcommentRetrieve(
			cofcommentId: string,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CofComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofcommentRetrieve(
					cofcommentId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {CofComment} cofComment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofcommentUpdate(
			cofcommentId: string,
			cofComment: CofComment,
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CofComment>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofcommentUpdate(
					cofcommentId,
					cofComment,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
	}
}

/**
 * CofcommentApi - factory interface
 * @export
 */
export const CofcommentApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CofcommentApiFp(configuration)
	return {
		/**
		 *
		 * @param {CofComment} cofComment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentCreate(
			cofComment: CofComment,
			options?: any
		): AxiosPromise<CofComment> {
			return localVarFp
				.cofcommentCreate(cofComment, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentDestroy(
			cofcommentId: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.cofcommentDestroy(cofcommentId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentList(options?: any): AxiosPromise<Array<CofComment>> {
			return localVarFp
				.cofcommentList(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {PatchedCofComment} [patchedCofComment]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentPartialUpdate(
			cofcommentId: string,
			patchedCofComment?: PatchedCofComment,
			options?: any
		): AxiosPromise<CofComment> {
			return localVarFp
				.cofcommentPartialUpdate(
					cofcommentId,
					patchedCofComment,
					options
				)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentRetrieve(
			cofcommentId: string,
			options?: any
		): AxiosPromise<CofComment> {
			return localVarFp
				.cofcommentRetrieve(cofcommentId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofcommentId A UUID string identifying this cof comment.
		 * @param {CofComment} cofComment
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofcommentUpdate(
			cofcommentId: string,
			cofComment: CofComment,
			options?: any
		): AxiosPromise<CofComment> {
			return localVarFp
				.cofcommentUpdate(cofcommentId, cofComment, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * CofcommentApi - object-oriented interface
 * @export
 * @class CofcommentApi
 * @extends {BaseAPI}
 */
export class CofcommentApi extends BaseAPI {
	/**
	 *
	 * @param {CofComment} cofComment
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofcommentApi
	 */
	public cofcommentCreate(
		cofComment: CofComment,
		options?: AxiosRequestConfig
	) {
		return CofcommentApiFp(this.configuration)
			.cofcommentCreate(cofComment, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofcommentId A UUID string identifying this cof comment.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofcommentApi
	 */
	public cofcommentDestroy(
		cofcommentId: string,
		options?: AxiosRequestConfig
	) {
		return CofcommentApiFp(this.configuration)
			.cofcommentDestroy(cofcommentId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofcommentApi
	 */
	public cofcommentList(options?: AxiosRequestConfig) {
		return CofcommentApiFp(this.configuration)
			.cofcommentList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofcommentId A UUID string identifying this cof comment.
	 * @param {PatchedCofComment} [patchedCofComment]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofcommentApi
	 */
	public cofcommentPartialUpdate(
		cofcommentId: string,
		patchedCofComment?: PatchedCofComment,
		options?: AxiosRequestConfig
	) {
		return CofcommentApiFp(this.configuration)
			.cofcommentPartialUpdate(cofcommentId, patchedCofComment, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofcommentId A UUID string identifying this cof comment.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofcommentApi
	 */
	public cofcommentRetrieve(
		cofcommentId: string,
		options?: AxiosRequestConfig
	) {
		return CofcommentApiFp(this.configuration)
			.cofcommentRetrieve(cofcommentId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofcommentId A UUID string identifying this cof comment.
	 * @param {CofComment} cofComment
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofcommentApi
	 */
	public cofcommentUpdate(
		cofcommentId: string,
		cofComment: CofComment,
		options?: AxiosRequestConfig
	) {
		return CofcommentApiFp(this.configuration)
			.cofcommentUpdate(cofcommentId, cofComment, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * CoffeeApi - axios parameter creator
 * @export
 */
export const CoffeeApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {Cof} cof
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeCreate: async (
			cof: Cof,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cof' is not null or undefined
			assertParamExists("coffeeCreate", "cof", cof)
			const localVarPath = `/coffee/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				cof,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeDestroy: async (
			cofId: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofId' is not null or undefined
			assertParamExists("coffeeDestroy", "cofId", cofId)
			const localVarPath = `/coffee/{cof_id}/`.replace(
				`{${"cof_id"}}`,
				encodeURIComponent(String(cofId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeList: async (
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/coffee/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {PatchedCof} [patchedCof]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeePartialUpdate: async (
			cofId: string,
			patchedCof?: PatchedCof,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofId' is not null or undefined
			assertParamExists("coffeePartialUpdate", "cofId", cofId)
			const localVarPath = `/coffee/{cof_id}/`.replace(
				`{${"cof_id"}}`,
				encodeURIComponent(String(cofId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedCof,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeRetrieve: async (
			cofId: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofId' is not null or undefined
			assertParamExists("coffeeRetrieve", "cofId", cofId)
			const localVarPath = `/coffee/{cof_id}/`.replace(
				`{${"cof_id"}}`,
				encodeURIComponent(String(cofId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {Cof} cof
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeUpdate: async (
			cofId: string,
			cof: Cof,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofId' is not null or undefined
			assertParamExists("coffeeUpdate", "cofId", cofId)
			// verify required parameter 'cof' is not null or undefined
			assertParamExists("coffeeUpdate", "cof", cof)
			const localVarPath = `/coffee/{cof_id}/`.replace(
				`{${"cof_id"}}`,
				encodeURIComponent(String(cofId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				cof,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CoffeeApi - functional programming interface
 * @export
 */
export const CoffeeApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CoffeeApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {Cof} cof
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coffeeCreate(
			cof: Cof,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cof>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.coffeeCreate(cof, options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coffeeDestroy(
			cofId: string,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.coffeeDestroy(cofId, options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coffeeList(
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<Cof>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.coffeeList(options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {PatchedCof} [patchedCof]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coffeePartialUpdate(
			cofId: string,
			patchedCof?: PatchedCof,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cof>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.coffeePartialUpdate(
					cofId,
					patchedCof,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coffeeRetrieve(
			cofId: string,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cof>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.coffeeRetrieve(cofId, options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {Cof} cof
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async coffeeUpdate(
			cofId: string,
			cof: Cof,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cof>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.coffeeUpdate(
					cofId,
					cof,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
	}
}

/**
 * CoffeeApi - factory interface
 * @export
 */
export const CoffeeApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CoffeeApiFp(configuration)
	return {
		/**
		 *
		 * @param {Cof} cof
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeCreate(cof: Cof, options?: any): AxiosPromise<Cof> {
			return localVarFp
				.coffeeCreate(cof, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeDestroy(cofId: string, options?: any): AxiosPromise<void> {
			return localVarFp
				.coffeeDestroy(cofId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeList(options?: any): AxiosPromise<Array<Cof>> {
			return localVarFp
				.coffeeList(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {PatchedCof} [patchedCof]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeePartialUpdate(
			cofId: string,
			patchedCof?: PatchedCof,
			options?: any
		): AxiosPromise<Cof> {
			return localVarFp
				.coffeePartialUpdate(cofId, patchedCof, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeRetrieve(cofId: string, options?: any): AxiosPromise<Cof> {
			return localVarFp
				.coffeeRetrieve(cofId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofId A UUID string identifying this cof.
		 * @param {Cof} cof
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		coffeeUpdate(
			cofId: string,
			cof: Cof,
			options?: any
		): AxiosPromise<Cof> {
			return localVarFp
				.coffeeUpdate(cofId, cof, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * CoffeeApi - object-oriented interface
 * @export
 * @class CoffeeApi
 * @extends {BaseAPI}
 */
export class CoffeeApi extends BaseAPI {
	/**
	 *
	 * @param {Cof} cof
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoffeeApi
	 */
	public coffeeCreate(cof: Cof, options?: AxiosRequestConfig) {
		return CoffeeApiFp(this.configuration)
			.coffeeCreate(cof, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofId A UUID string identifying this cof.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoffeeApi
	 */
	public coffeeDestroy(cofId: string, options?: AxiosRequestConfig) {
		return CoffeeApiFp(this.configuration)
			.coffeeDestroy(cofId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoffeeApi
	 */
	public coffeeList(options?: AxiosRequestConfig) {
		return CoffeeApiFp(this.configuration)
			.coffeeList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofId A UUID string identifying this cof.
	 * @param {PatchedCof} [patchedCof]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoffeeApi
	 */
	public coffeePartialUpdate(
		cofId: string,
		patchedCof?: PatchedCof,
		options?: AxiosRequestConfig
	) {
		return CoffeeApiFp(this.configuration)
			.coffeePartialUpdate(cofId, patchedCof, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofId A UUID string identifying this cof.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoffeeApi
	 */
	public coffeeRetrieve(cofId: string, options?: AxiosRequestConfig) {
		return CoffeeApiFp(this.configuration)
			.coffeeRetrieve(cofId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofId A UUID string identifying this cof.
	 * @param {Cof} cof
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CoffeeApi
	 */
	public coffeeUpdate(cofId: string, cof: Cof, options?: AxiosRequestConfig) {
		return CoffeeApiFp(this.configuration)
			.coffeeUpdate(cofId, cof, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * CofpullApi - axios parameter creator
 * @export
 */
export const CofpullApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {CofPull} cofPull
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullCreate: async (
			cofPull: CofPull,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofPull' is not null or undefined
			assertParamExists("cofpullCreate", "cofPull", cofPull)
			const localVarPath = `/cofpull/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				cofPull,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullDestroy: async (
			cofpullId: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofpullId' is not null or undefined
			assertParamExists("cofpullDestroy", "cofpullId", cofpullId)
			const localVarPath = `/cofpull/{cofpull_id}/`.replace(
				`{${"cofpull_id"}}`,
				encodeURIComponent(String(cofpullId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullList: async (
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/cofpull/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {PatchedCofPull} [patchedCofPull]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullPartialUpdate: async (
			cofpullId: string,
			patchedCofPull?: PatchedCofPull,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofpullId' is not null or undefined
			assertParamExists("cofpullPartialUpdate", "cofpullId", cofpullId)
			const localVarPath = `/cofpull/{cofpull_id}/`.replace(
				`{${"cofpull_id"}}`,
				encodeURIComponent(String(cofpullId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				patchedCofPull,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullRetrieve: async (
			cofpullId: string,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofpullId' is not null or undefined
			assertParamExists("cofpullRetrieve", "cofpullId", cofpullId)
			const localVarPath = `/cofpull/{cofpull_id}/`.replace(
				`{${"cofpull_id"}}`,
				encodeURIComponent(String(cofpullId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {CofPull} cofPull
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullUpdate: async (
			cofpullId: string,
			cofPull: CofPull,
			options: AxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'cofpullId' is not null or undefined
			assertParamExists("cofpullUpdate", "cofpullId", cofpullId)
			// verify required parameter 'cofPull' is not null or undefined
			assertParamExists("cofpullUpdate", "cofPull", cofPull)
			const localVarPath = `/cofpull/{cofpull_id}/`.replace(
				`{${"cofpull_id"}}`,
				encodeURIComponent(String(cofpullId))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication jwtAuth required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter["Content-Type"] = "application/json"

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				cofPull,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * CofpullApi - functional programming interface
 * @export
 */
export const CofpullApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CofpullApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {CofPull} cofPull
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofpullCreate(
			cofPull: CofPull,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CofPull>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofpullCreate(cofPull, options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofpullDestroy(
			cofpullId: string,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofpullDestroy(
					cofpullId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofpullList(
			options?: AxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<CofPull>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofpullList(options)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {PatchedCofPull} [patchedCofPull]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofpullPartialUpdate(
			cofpullId: string,
			patchedCofPull?: PatchedCofPull,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CofPull>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofpullPartialUpdate(
					cofpullId,
					patchedCofPull,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofpullRetrieve(
			cofpullId: string,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CofPull>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofpullRetrieve(
					cofpullId,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {CofPull} cofPull
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async cofpullUpdate(
			cofpullId: string,
			cofPull: CofPull,
			options?: AxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CofPull>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.cofpullUpdate(
					cofpullId,
					cofPull,
					options
				)
			return createRequestFunction(
				localVarAxiosArgs,
				globalAxios,
				BASE_PATH,
				configuration
			)
		},
	}
}

/**
 * CofpullApi - factory interface
 * @export
 */
export const CofpullApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = CofpullApiFp(configuration)
	return {
		/**
		 *
		 * @param {CofPull} cofPull
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullCreate(cofPull: CofPull, options?: any): AxiosPromise<CofPull> {
			return localVarFp
				.cofpullCreate(cofPull, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullDestroy(cofpullId: string, options?: any): AxiosPromise<void> {
			return localVarFp
				.cofpullDestroy(cofpullId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullList(options?: any): AxiosPromise<Array<CofPull>> {
			return localVarFp
				.cofpullList(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {PatchedCofPull} [patchedCofPull]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullPartialUpdate(
			cofpullId: string,
			patchedCofPull?: PatchedCofPull,
			options?: any
		): AxiosPromise<CofPull> {
			return localVarFp
				.cofpullPartialUpdate(cofpullId, patchedCofPull, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullRetrieve(
			cofpullId: string,
			options?: any
		): AxiosPromise<CofPull> {
			return localVarFp
				.cofpullRetrieve(cofpullId, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} cofpullId A UUID string identifying this cof pull.
		 * @param {CofPull} cofPull
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		cofpullUpdate(
			cofpullId: string,
			cofPull: CofPull,
			options?: any
		): AxiosPromise<CofPull> {
			return localVarFp
				.cofpullUpdate(cofpullId, cofPull, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * CofpullApi - object-oriented interface
 * @export
 * @class CofpullApi
 * @extends {BaseAPI}
 */
export class CofpullApi extends BaseAPI {
	/**
	 *
	 * @param {CofPull} cofPull
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofpullApi
	 */
	public cofpullCreate(cofPull: CofPull, options?: AxiosRequestConfig) {
		return CofpullApiFp(this.configuration)
			.cofpullCreate(cofPull, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofpullId A UUID string identifying this cof pull.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofpullApi
	 */
	public cofpullDestroy(cofpullId: string, options?: AxiosRequestConfig) {
		return CofpullApiFp(this.configuration)
			.cofpullDestroy(cofpullId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofpullApi
	 */
	public cofpullList(options?: AxiosRequestConfig) {
		return CofpullApiFp(this.configuration)
			.cofpullList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofpullId A UUID string identifying this cof pull.
	 * @param {PatchedCofPull} [patchedCofPull]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofpullApi
	 */
	public cofpullPartialUpdate(
		cofpullId: string,
		patchedCofPull?: PatchedCofPull,
		options?: AxiosRequestConfig
	) {
		return CofpullApiFp(this.configuration)
			.cofpullPartialUpdate(cofpullId, patchedCofPull, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofpullId A UUID string identifying this cof pull.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofpullApi
	 */
	public cofpullRetrieve(cofpullId: string, options?: AxiosRequestConfig) {
		return CofpullApiFp(this.configuration)
			.cofpullRetrieve(cofpullId, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} cofpullId A UUID string identifying this cof pull.
	 * @param {CofPull} cofPull
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CofpullApi
	 */
	public cofpullUpdate(
		cofpullId: string,
		cofPull: CofPull,
		options?: AxiosRequestConfig
	) {
		return CofpullApiFp(this.configuration)
			.cofpullUpdate(cofpullId, cofPull, options)
			.then((request) => request(this.axios, this.basePath))
	}
}
